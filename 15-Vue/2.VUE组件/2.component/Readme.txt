1.组件化开发基本流程：
(1) 拆分组件：拆分页面，定义组件
(2) 静态组件：使用组件搭建静态页面
(3) 动态组件：
    A.初始化动态显示
    B.交互，包括移入移出效果、添加、删除操作

2.设计数据：
    (1) 数据类型
    (2) 数据名称
    (3) 放在哪个组件

3.模板数据的来源：
    (1) data：自身可变数据
    (2) props：从外部接收的可变数据
    (3) computed：根据已有的data或props数据进行计算产生的数据

4.Vue的组件对象与Vue的关系(通过在组件对象中打印this证明)
    (1) 组件对象不是Vue的实例对象，而是VueComponent的实例
    (2) 组件对象的原型对象是一个vm对象(Vue的实例对象)
    (3) 在组件中读取this.xx的查找顺序：组件对象自身上查找 ==> vm对象上查找 ==> Vue的原型对象上查找
    (4) Vue的原型对象只有一个，而每个组件对象都有其对应的原型对象(通过在this.__proto__和this.__proto__.__proto__挂载属性并在其他组件读取属性证明)
    之前通过自定义组件进行通信是父子组件或祖孙组件间的通信，知道上述结论后，可以先在Vue的原型对象挂在一个vm对象，这样任意组件都能读取到，
    然后在相关组件上分别对该vm进行绑定事件监听和事件分发(this.$vm.$on和this.$vm.$emit和this.$vm.$off)，实现任意组件间的通信。这样vm就叫做全局事件总线(Global Event Bus)

-------------------------------- 分隔 --------------------------------

1.组件通信：
    (1) props(父组件向子组件通信)
        A.过程：从父组件将数据传入子组件(:xxx="xxx") => 在子组件声明接收属性(三种方式) => 在子组件使用数据
        B.不能实现子向父的通信，会导致数据混乱
        C.可以借助一个父组件作为中间件实现兄弟组件间的通信，但一般不用此方式
    (2) $emit(子组件向父组件的通信)
        A.过程(参考本示例中的addTodo)：在父组间中定义事件(声明函数) => 绑定事件监听 => 在子组件中分发事件this.$emit('事件名',[,可选传参])
        B.绑定事件监听的两种方式：一、在父组间中给子组件绑定事件监听(@事件名="回调函数") 
                                二、在父组间mounted中绑定事件监听(this.$on('xxx', this.xxx))，注意此时this必须是分发事件的子组件，故需要通过this.$refs.子组件名.$on('xxx', this.xxx)
    (3) $emit(任意组件的通信)
        A.Vue的原型对象只有一个，而每个组件对象都有其对应的原型对象
        B.之前通过自定义组件进行通信是父子组件或祖孙组件间的通信，知道上述结论后，可以先在Vue的原型对象挂在一个vm对象，这样任意组件都能读取到，
        然后在相关组件上分别对该vm进行绑定事件监听和事件分发(this.$vm.$emit、this.$vm.$off和this.$vm.$on)，实现任意组件间的通信。这种vm就叫做全局事件总线(Global Event Bus)
        C.实现过程参考本示例中的deleteTodo
    (4) slot插槽(父组件向子组件通信)
        A.过程(参考本示例中的Footer功能的实现)：在子组件中定义插槽(默认插槽、命名插槽和作用域插槽) => 在父组件中向插槽传入内容
        B.与props不同点：props传的是数据，slot传的是带数据的标签